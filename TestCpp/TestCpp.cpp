#include <iostream>
#include <fstream>
using namespace std;

/*int main()
{
	ifstream Text; //создание кодового слова для файла
	Text.open("42.txt", ios_base::in); //открытие файла
	int answer = 0; //переменная для конечного результата
	while (!Text.eof()) //основой цикл, работающий пока файл не закончится
	{
		int powNum = -1; //переменная для повторяющегося числа. 
		int Arr[6]; //массив для записи всех 6 чисел строки
		int two = 0; // счетчик повторяющихся чисел
		float sum = 0; // переменная для суммы всех чисел строки
		for (int i = 0; i != 6; i++) // цикл, записывающий получаемые числа в массив
		{
			Text >> Arr[i]; //запись числа в массив
		}
		for (int a = 0; a != 6; a++)//цикл для проверки равенства чисел
		{
			for (int b = a + 1; b != 6; b++)//цикл второго уровня
			{
				if (Arr[a] == Arr[b])//если обнаружены одинаковые числа, то:
				{
					two++; //увеличить переменную счетчик на 1
					powNum = Arr[a]; //присвоить значение повторяемому числу
				}				
			}
		}
		for (int i = 0; i != 6; i++){sum += Arr[i];}//цикл для счета суммы всех чисел строки 
		if (two == 1 && ((sum - powNum * 2) / 4 <= powNum * 2))//проверка по условию задачи
		{
			answer++;//если истина, увеличить переменную счетчик на 1
		}
	}
	cout << "Lines count: " << answer;//вывод ответа в консоль
}*/

/*   //Инициализация вершин и расстояний
        for (int i = 0; i < build; i++)
        {
            d[i] = 10000;
            v[i] = 1;
        }
        d[begin_index] = 0;
        // Шаг алгоритма
        do {
            minindex = 10000;
            min = 10000;
            for (int i = 0; i < build; i++)
            { // Если вершину ещё не обошли и вес меньше min
                if ((v[i] == 1) && (d[i] < min))
                { // Переприсваиваем значения
                    min = d[i];
                    minindex = i;
                }
            }
            // Добавляем найденный минимальный вес
            // к текущему весу вершины
            // и сравниваем с текущим минимальным весом вершины
            if (minindex != 10000)
            {
                for (int i = 0; i < build; i++)
                {
                    if (Matrix[minindex][i] > 0)
                    {
                        temp = min + Matrix[minindex][i];
                        if (temp < d[i])
                        {
                            d[i] = temp;
                        }
                    }
                }
                v[minindex] = 0;
            }
        } while (minindex < 10000);

        // Восстановление пути
        vector<int> ver(build); // массив посещенных вершин
        int end = school - 1;
        ver[0] = end + 1; // начальный элемент - конечная вершина
        int k = home; // индекс предыдущей вершины
        int weight = d[end]; // вес конечной вершины

        while (end != begin_index) // пока не дошли до начальной вершины
        {
            for (int i = 0; i < build; i++) // просматриваем все вершины
                if (Matrix[i][end] != 0)   // если связь есть
                {
                    int temp = weight - Matrix[i][end]; // определяем вес пути из предыдущей вершины
                    if (temp == d[i]) // если вес совпал с рассчитанным
                    {                 // значит из этой вершины и был переход
                        weight = temp; // сохраняем новый вес
                        end = i;       // сохраняем предыдущую вершину
                        ver[k] = i + 1; // и записываем ее в массив
                        k++;
                    }
                }
        }
        // Вывод пути (начальная вершина оказалась в конце массива из k элементов)
        for (int i = k - 1; i >= 0; i--)
            ansr_distance += ver[i];
        for (int i = k - 1; i >= 0; i--)
            cout << ansr_distance << endl << size(ver) - 2;
    }*/